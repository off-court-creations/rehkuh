[
  {
    "name": "trippySphere_0",
    "type": "sphere",
    "position": [
      -12.5,
      -12.5,
      -12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_1",
    "type": "sphere",
    "position": [
      -7.5,
      -12.5,
      -12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_2",
    "type": "sphere",
    "position": [
      -2.5,
      -12.5,
      -12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_3",
    "type": "sphere",
    "position": [
      2.5,
      -12.5,
      -12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_4",
    "type": "sphere",
    "position": [
      7.5,
      -12.5,
      -12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_5",
    "type": "sphere",
    "position": [
      12.5,
      -12.5,
      -12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_6",
    "type": "sphere",
    "position": [
      -12.5,
      -12.5,
      -7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_7",
    "type": "sphere",
    "position": [
      -7.5,
      -12.5,
      -7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_8",
    "type": "sphere",
    "position": [
      -2.5,
      -12.5,
      -7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_9",
    "type": "sphere",
    "position": [
      2.5,
      -12.5,
      -7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_10",
    "type": "sphere",
    "position": [
      7.5,
      -12.5,
      -7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_11",
    "type": "sphere",
    "position": [
      12.5,
      -12.5,
      -7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_12",
    "type": "sphere",
    "position": [
      -12.5,
      -12.5,
      -2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_13",
    "type": "sphere",
    "position": [
      -7.5,
      -12.5,
      -2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_14",
    "type": "sphere",
    "position": [
      -2.5,
      -12.5,
      -2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_15",
    "type": "sphere",
    "position": [
      2.5,
      -12.5,
      -2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_16",
    "type": "sphere",
    "position": [
      7.5,
      -12.5,
      -2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_17",
    "type": "sphere",
    "position": [
      12.5,
      -12.5,
      -2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_18",
    "type": "sphere",
    "position": [
      -12.5,
      -12.5,
      2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_19",
    "type": "sphere",
    "position": [
      -7.5,
      -12.5,
      2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_20",
    "type": "sphere",
    "position": [
      -2.5,
      -12.5,
      2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_21",
    "type": "sphere",
    "position": [
      2.5,
      -12.5,
      2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_22",
    "type": "sphere",
    "position": [
      7.5,
      -12.5,
      2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_23",
    "type": "sphere",
    "position": [
      12.5,
      -12.5,
      2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_24",
    "type": "sphere",
    "position": [
      -12.5,
      -12.5,
      7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_25",
    "type": "sphere",
    "position": [
      -7.5,
      -12.5,
      7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_26",
    "type": "sphere",
    "position": [
      -2.5,
      -12.5,
      7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_27",
    "type": "sphere",
    "position": [
      2.5,
      -12.5,
      7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_28",
    "type": "sphere",
    "position": [
      7.5,
      -12.5,
      7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_29",
    "type": "sphere",
    "position": [
      12.5,
      -12.5,
      7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_30",
    "type": "sphere",
    "position": [
      -12.5,
      -12.5,
      12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_31",
    "type": "sphere",
    "position": [
      -7.5,
      -12.5,
      12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_32",
    "type": "sphere",
    "position": [
      -2.5,
      -12.5,
      12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_33",
    "type": "sphere",
    "position": [
      2.5,
      -12.5,
      12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_34",
    "type": "sphere",
    "position": [
      7.5,
      -12.5,
      12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_35",
    "type": "sphere",
    "position": [
      12.5,
      -12.5,
      12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_36",
    "type": "sphere",
    "position": [
      -12.5,
      -7.5,
      -12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_37",
    "type": "sphere",
    "position": [
      -7.5,
      -7.5,
      -12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_38",
    "type": "sphere",
    "position": [
      -2.5,
      -7.5,
      -12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_39",
    "type": "sphere",
    "position": [
      2.5,
      -7.5,
      -12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_40",
    "type": "sphere",
    "position": [
      7.5,
      -7.5,
      -12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_41",
    "type": "sphere",
    "position": [
      12.5,
      -7.5,
      -12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_42",
    "type": "sphere",
    "position": [
      -12.5,
      -7.5,
      -7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_43",
    "type": "sphere",
    "position": [
      -7.5,
      -7.5,
      -7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_44",
    "type": "sphere",
    "position": [
      -2.5,
      -7.5,
      -7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_45",
    "type": "sphere",
    "position": [
      2.5,
      -7.5,
      -7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_46",
    "type": "sphere",
    "position": [
      7.5,
      -7.5,
      -7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_47",
    "type": "sphere",
    "position": [
      12.5,
      -7.5,
      -7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_48",
    "type": "sphere",
    "position": [
      -12.5,
      -7.5,
      -2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_49",
    "type": "sphere",
    "position": [
      -7.5,
      -7.5,
      -2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_50",
    "type": "sphere",
    "position": [
      -2.5,
      -7.5,
      -2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_51",
    "type": "sphere",
    "position": [
      2.5,
      -7.5,
      -2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_52",
    "type": "sphere",
    "position": [
      7.5,
      -7.5,
      -2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_53",
    "type": "sphere",
    "position": [
      12.5,
      -7.5,
      -2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_54",
    "type": "sphere",
    "position": [
      -12.5,
      -7.5,
      2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_55",
    "type": "sphere",
    "position": [
      -7.5,
      -7.5,
      2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_56",
    "type": "sphere",
    "position": [
      -2.5,
      -7.5,
      2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_57",
    "type": "sphere",
    "position": [
      2.5,
      -7.5,
      2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_58",
    "type": "sphere",
    "position": [
      7.5,
      -7.5,
      2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_59",
    "type": "sphere",
    "position": [
      12.5,
      -7.5,
      2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_60",
    "type": "sphere",
    "position": [
      -12.5,
      -7.5,
      7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_61",
    "type": "sphere",
    "position": [
      -7.5,
      -7.5,
      7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_62",
    "type": "sphere",
    "position": [
      -2.5,
      -7.5,
      7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_63",
    "type": "sphere",
    "position": [
      2.5,
      -7.5,
      7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_64",
    "type": "sphere",
    "position": [
      7.5,
      -7.5,
      7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_65",
    "type": "sphere",
    "position": [
      12.5,
      -7.5,
      7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_66",
    "type": "sphere",
    "position": [
      -12.5,
      -7.5,
      12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_67",
    "type": "sphere",
    "position": [
      -7.5,
      -7.5,
      12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_68",
    "type": "sphere",
    "position": [
      -2.5,
      -7.5,
      12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_69",
    "type": "sphere",
    "position": [
      2.5,
      -7.5,
      12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_70",
    "type": "sphere",
    "position": [
      7.5,
      -7.5,
      12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_71",
    "type": "sphere",
    "position": [
      12.5,
      -7.5,
      12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_72",
    "type": "sphere",
    "position": [
      -12.5,
      -2.5,
      -12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_73",
    "type": "sphere",
    "position": [
      -7.5,
      -2.5,
      -12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_74",
    "type": "sphere",
    "position": [
      -2.5,
      -2.5,
      -12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_75",
    "type": "sphere",
    "position": [
      2.5,
      -2.5,
      -12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_76",
    "type": "sphere",
    "position": [
      7.5,
      -2.5,
      -12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_77",
    "type": "sphere",
    "position": [
      12.5,
      -2.5,
      -12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_78",
    "type": "sphere",
    "position": [
      -12.5,
      -2.5,
      -7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_79",
    "type": "sphere",
    "position": [
      -7.5,
      -2.5,
      -7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_80",
    "type": "sphere",
    "position": [
      -2.5,
      -2.5,
      -7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_81",
    "type": "sphere",
    "position": [
      2.5,
      -2.5,
      -7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_82",
    "type": "sphere",
    "position": [
      7.5,
      -2.5,
      -7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_83",
    "type": "sphere",
    "position": [
      12.5,
      -2.5,
      -7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_84",
    "type": "sphere",
    "position": [
      -12.5,
      -2.5,
      -2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_85",
    "type": "sphere",
    "position": [
      -7.5,
      -2.5,
      -2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_86",
    "type": "sphere",
    "position": [
      -2.5,
      -2.5,
      -2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_87",
    "type": "sphere",
    "position": [
      2.5,
      -2.5,
      -2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_88",
    "type": "sphere",
    "position": [
      7.5,
      -2.5,
      -2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_89",
    "type": "sphere",
    "position": [
      12.5,
      -2.5,
      -2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_90",
    "type": "sphere",
    "position": [
      -12.5,
      -2.5,
      2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_91",
    "type": "sphere",
    "position": [
      -7.5,
      -2.5,
      2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_92",
    "type": "sphere",
    "position": [
      -2.5,
      -2.5,
      2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_93",
    "type": "sphere",
    "position": [
      2.5,
      -2.5,
      2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_94",
    "type": "sphere",
    "position": [
      7.5,
      -2.5,
      2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_95",
    "type": "sphere",
    "position": [
      12.5,
      -2.5,
      2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_96",
    "type": "sphere",
    "position": [
      -12.5,
      -2.5,
      7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_97",
    "type": "sphere",
    "position": [
      -7.5,
      -2.5,
      7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_98",
    "type": "sphere",
    "position": [
      -2.5,
      -2.5,
      7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_99",
    "type": "sphere",
    "position": [
      2.5,
      -2.5,
      7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_100",
    "type": "sphere",
    "position": [
      7.5,
      -2.5,
      7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_101",
    "type": "sphere",
    "position": [
      12.5,
      -2.5,
      7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_102",
    "type": "sphere",
    "position": [
      -12.5,
      -2.5,
      12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_103",
    "type": "sphere",
    "position": [
      -7.5,
      -2.5,
      12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_104",
    "type": "sphere",
    "position": [
      -2.5,
      -2.5,
      12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_105",
    "type": "sphere",
    "position": [
      2.5,
      -2.5,
      12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_106",
    "type": "sphere",
    "position": [
      7.5,
      -2.5,
      12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_107",
    "type": "sphere",
    "position": [
      12.5,
      -2.5,
      12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_108",
    "type": "sphere",
    "position": [
      -12.5,
      2.5,
      -12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_109",
    "type": "sphere",
    "position": [
      -7.5,
      2.5,
      -12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_110",
    "type": "sphere",
    "position": [
      -2.5,
      2.5,
      -12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_111",
    "type": "sphere",
    "position": [
      2.5,
      2.5,
      -12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_112",
    "type": "sphere",
    "position": [
      7.5,
      2.5,
      -12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_113",
    "type": "sphere",
    "position": [
      12.5,
      2.5,
      -12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_114",
    "type": "sphere",
    "position": [
      -12.5,
      2.5,
      -7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_115",
    "type": "sphere",
    "position": [
      -7.5,
      2.5,
      -7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_116",
    "type": "sphere",
    "position": [
      -2.5,
      2.5,
      -7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_117",
    "type": "sphere",
    "position": [
      2.5,
      2.5,
      -7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_118",
    "type": "sphere",
    "position": [
      7.5,
      2.5,
      -7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_119",
    "type": "sphere",
    "position": [
      12.5,
      2.5,
      -7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_120",
    "type": "sphere",
    "position": [
      -12.5,
      2.5,
      -2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_121",
    "type": "sphere",
    "position": [
      -7.5,
      2.5,
      -2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_122",
    "type": "sphere",
    "position": [
      -2.5,
      2.5,
      -2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_123",
    "type": "sphere",
    "position": [
      2.5,
      2.5,
      -2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_124",
    "type": "sphere",
    "position": [
      7.5,
      2.5,
      -2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_125",
    "type": "sphere",
    "position": [
      12.5,
      2.5,
      -2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_126",
    "type": "sphere",
    "position": [
      -12.5,
      2.5,
      2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_127",
    "type": "sphere",
    "position": [
      -7.5,
      2.5,
      2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_128",
    "type": "sphere",
    "position": [
      -2.5,
      2.5,
      2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_129",
    "type": "sphere",
    "position": [
      2.5,
      2.5,
      2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_130",
    "type": "sphere",
    "position": [
      7.5,
      2.5,
      2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_131",
    "type": "sphere",
    "position": [
      12.5,
      2.5,
      2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_132",
    "type": "sphere",
    "position": [
      -12.5,
      2.5,
      7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_133",
    "type": "sphere",
    "position": [
      -7.5,
      2.5,
      7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_134",
    "type": "sphere",
    "position": [
      -2.5,
      2.5,
      7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_135",
    "type": "sphere",
    "position": [
      2.5,
      2.5,
      7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_136",
    "type": "sphere",
    "position": [
      7.5,
      2.5,
      7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_137",
    "type": "sphere",
    "position": [
      12.5,
      2.5,
      7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_138",
    "type": "sphere",
    "position": [
      -12.5,
      2.5,
      12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_139",
    "type": "sphere",
    "position": [
      -7.5,
      2.5,
      12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_140",
    "type": "sphere",
    "position": [
      -2.5,
      2.5,
      12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_141",
    "type": "sphere",
    "position": [
      2.5,
      2.5,
      12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_142",
    "type": "sphere",
    "position": [
      7.5,
      2.5,
      12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_143",
    "type": "sphere",
    "position": [
      12.5,
      2.5,
      12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_144",
    "type": "sphere",
    "position": [
      -12.5,
      7.5,
      -12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_145",
    "type": "sphere",
    "position": [
      -7.5,
      7.5,
      -12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_146",
    "type": "sphere",
    "position": [
      -2.5,
      7.5,
      -12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_147",
    "type": "sphere",
    "position": [
      2.5,
      7.5,
      -12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_148",
    "type": "sphere",
    "position": [
      7.5,
      7.5,
      -12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_149",
    "type": "sphere",
    "position": [
      12.5,
      7.5,
      -12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_150",
    "type": "sphere",
    "position": [
      -12.5,
      7.5,
      -7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_151",
    "type": "sphere",
    "position": [
      -7.5,
      7.5,
      -7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_152",
    "type": "sphere",
    "position": [
      -2.5,
      7.5,
      -7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_153",
    "type": "sphere",
    "position": [
      2.5,
      7.5,
      -7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_154",
    "type": "sphere",
    "position": [
      7.5,
      7.5,
      -7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_155",
    "type": "sphere",
    "position": [
      12.5,
      7.5,
      -7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_156",
    "type": "sphere",
    "position": [
      -12.5,
      7.5,
      -2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_157",
    "type": "sphere",
    "position": [
      -7.5,
      7.5,
      -2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_158",
    "type": "sphere",
    "position": [
      -2.5,
      7.5,
      -2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_159",
    "type": "sphere",
    "position": [
      2.5,
      7.5,
      -2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_160",
    "type": "sphere",
    "position": [
      7.5,
      7.5,
      -2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_161",
    "type": "sphere",
    "position": [
      12.5,
      7.5,
      -2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_162",
    "type": "sphere",
    "position": [
      -12.5,
      7.5,
      2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_163",
    "type": "sphere",
    "position": [
      -7.5,
      7.5,
      2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_164",
    "type": "sphere",
    "position": [
      -2.5,
      7.5,
      2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_165",
    "type": "sphere",
    "position": [
      2.5,
      7.5,
      2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_166",
    "type": "sphere",
    "position": [
      7.5,
      7.5,
      2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_167",
    "type": "sphere",
    "position": [
      12.5,
      7.5,
      2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_168",
    "type": "sphere",
    "position": [
      -12.5,
      7.5,
      7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_169",
    "type": "sphere",
    "position": [
      -7.5,
      7.5,
      7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_170",
    "type": "sphere",
    "position": [
      -2.5,
      7.5,
      7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_171",
    "type": "sphere",
    "position": [
      2.5,
      7.5,
      7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_172",
    "type": "sphere",
    "position": [
      7.5,
      7.5,
      7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_173",
    "type": "sphere",
    "position": [
      12.5,
      7.5,
      7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_174",
    "type": "sphere",
    "position": [
      -12.5,
      7.5,
      12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_175",
    "type": "sphere",
    "position": [
      -7.5,
      7.5,
      12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_176",
    "type": "sphere",
    "position": [
      -2.5,
      7.5,
      12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_177",
    "type": "sphere",
    "position": [
      2.5,
      7.5,
      12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_178",
    "type": "sphere",
    "position": [
      7.5,
      7.5,
      12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_179",
    "type": "sphere",
    "position": [
      12.5,
      7.5,
      12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_180",
    "type": "sphere",
    "position": [
      -12.5,
      12.5,
      -12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_181",
    "type": "sphere",
    "position": [
      -7.5,
      12.5,
      -12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_182",
    "type": "sphere",
    "position": [
      -2.5,
      12.5,
      -12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_183",
    "type": "sphere",
    "position": [
      2.5,
      12.5,
      -12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_184",
    "type": "sphere",
    "position": [
      7.5,
      12.5,
      -12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_185",
    "type": "sphere",
    "position": [
      12.5,
      12.5,
      -12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_186",
    "type": "sphere",
    "position": [
      -12.5,
      12.5,
      -7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_187",
    "type": "sphere",
    "position": [
      -7.5,
      12.5,
      -7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_188",
    "type": "sphere",
    "position": [
      -2.5,
      12.5,
      -7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_189",
    "type": "sphere",
    "position": [
      2.5,
      12.5,
      -7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_190",
    "type": "sphere",
    "position": [
      7.5,
      12.5,
      -7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_191",
    "type": "sphere",
    "position": [
      12.5,
      12.5,
      -7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_192",
    "type": "sphere",
    "position": [
      -12.5,
      12.5,
      -2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_193",
    "type": "sphere",
    "position": [
      -7.5,
      12.5,
      -2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_194",
    "type": "sphere",
    "position": [
      -2.5,
      12.5,
      -2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_195",
    "type": "sphere",
    "position": [
      2.5,
      12.5,
      -2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_196",
    "type": "sphere",
    "position": [
      7.5,
      12.5,
      -2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_197",
    "type": "sphere",
    "position": [
      12.5,
      12.5,
      -2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_198",
    "type": "sphere",
    "position": [
      -12.5,
      12.5,
      2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_199",
    "type": "sphere",
    "position": [
      -7.5,
      12.5,
      2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_200",
    "type": "sphere",
    "position": [
      -2.5,
      12.5,
      2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_201",
    "type": "sphere",
    "position": [
      2.5,
      12.5,
      2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_202",
    "type": "sphere",
    "position": [
      7.5,
      12.5,
      2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_203",
    "type": "sphere",
    "position": [
      12.5,
      12.5,
      2.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_204",
    "type": "sphere",
    "position": [
      -12.5,
      12.5,
      7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_205",
    "type": "sphere",
    "position": [
      -7.5,
      12.5,
      7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_206",
    "type": "sphere",
    "position": [
      -2.5,
      12.5,
      7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_207",
    "type": "sphere",
    "position": [
      2.5,
      12.5,
      7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_208",
    "type": "sphere",
    "position": [
      7.5,
      12.5,
      7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_209",
    "type": "sphere",
    "position": [
      12.5,
      12.5,
      7.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_210",
    "type": "sphere",
    "position": [
      -12.5,
      12.5,
      12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_211",
    "type": "sphere",
    "position": [
      -7.5,
      12.5,
      12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_212",
    "type": "sphere",
    "position": [
      -2.5,
      12.5,
      12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_213",
    "type": "sphere",
    "position": [
      2.5,
      12.5,
      12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_214",
    "type": "sphere",
    "position": [
      7.5,
      12.5,
      12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  },
  {
    "name": "trippySphere_215",
    "type": "sphere",
    "position": [
      12.5,
      12.5,
      12.5
    ],
    "rotation": [
      0,
      0,
      0
    ],
    "scale": [
      2,
      2,
      2
    ],
    "material": {
      "type": "shader",
      "shaderName": "trippy",
      "vertex": "uniform float time;\nuniform float displacementStrength;\nuniform float noiseScale;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// Simplex-like noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat fbm(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * snoise(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\nvoid main() {\n  vUv = uv;\n  vNormal = normal;\n  vPosition = position;\n\n  // Animate noise sample position\n  vec3 noisePos = position * noiseScale + vec3(\n    sin(time * 0.3) * 0.5,\n    cos(time * 0.4) * 0.5,\n    sin(time * 0.5) * 0.5\n  );\n\n  // Layer multiple noise frequencies for trippy effect\n  float noise1 = fbm(noisePos + time * 0.2);\n  float noise2 = snoise(noisePos * 2.0 - time * 0.3);\n  float noise3 = snoise(noisePos * 0.5 + time * 0.1);\n\n  // Combine noises for complex displacement\n  float displacement = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n  displacement *= displacementStrength;\n\n  vDisplacement = displacement;\n\n  // Displace along normal\n  vec3 newPosition = position + normal * displacement;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",
      "fragment": "uniform float time;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 color3;\nuniform float colorSpeed;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vDisplacement;\n\n// HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Create flowing color bands based on position and time\n  float angle = atan(vPosition.z, vPosition.x);\n  float radius = length(vPosition.xz);\n\n  // Psychedelic spiral pattern\n  float spiral = angle * 3.0 + vPosition.y * 4.0 + time * colorSpeed;\n  float wave = sin(spiral) * 0.5 + 0.5;\n\n  // Rainbow hue shift based on displacement and position\n  float hue = fract(\n    vDisplacement * 2.0 +\n    vPosition.y * 0.5 +\n    time * 0.1 +\n    sin(angle * 3.0 + time) * 0.2\n  );\n\n  // Saturation varies with displacement\n  float sat = 0.7 + sin(vDisplacement * 10.0 + time) * 0.3;\n\n  // Value/brightness pulses\n  float val = 0.8 + sin(time * 2.0 + vPosition.y * 5.0) * 0.2;\n\n  // Base rainbow color\n  vec3 rainbow = hsv2rgb(vec3(hue, sat, val));\n\n  // Mix with user colors based on wave patterns\n  float mix1 = sin(spiral * 0.5) * 0.5 + 0.5;\n  float mix2 = cos(spiral * 0.7 + 1.0) * 0.5 + 0.5;\n\n  vec3 colorMix = mix(color1, color2, mix1);\n  colorMix = mix(colorMix, color3, mix2 * 0.5);\n\n  // Blend rainbow with color mix\n  vec3 finalColor = mix(rainbow, colorMix, 0.4);\n\n  // Add glow based on displacement peaks\n  float glow = smoothstep(0.0, 0.3, abs(vDisplacement)) * 0.3;\n  finalColor += glow;\n\n  // Fresnel-like edge glow\n  vec3 viewDir = normalize(cameraPosition - vPosition);\n  float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);\n  finalColor += fresnel * 0.3 * rainbow;\n\n  gl_FragColor = vec4(finalColor, 1.0);\n}\n",
      "uniforms": {
        "time": {
          "type": "float",
          "value": 0,
          "animated": true
        },
        "displacementStrength": {
          "type": "float",
          "value": 0.3,
          "min": 0,
          "max": 1,
          "step": 0.01
        },
        "noiseScale": {
          "type": "float",
          "value": 2,
          "min": 0.5,
          "max": 5,
          "step": 0.1
        },
        "colorSpeed": {
          "type": "float",
          "value": 1,
          "min": 0.1,
          "max": 3,
          "step": 0.1
        },
        "color1": {
          "type": "color",
          "value": "#ff00ff"
        },
        "color2": {
          "type": "color",
          "value": "#00ffff"
        },
        "color3": {
          "type": "color",
          "value": "#ffff00"
        }
      }
    },
    "sphereWidthSegments": 64,
    "sphereHeightSegments": 32
  }
]